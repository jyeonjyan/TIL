# 백엔드 기술면접 이정도는 대답하자.

## 객체지향에 대해서 설명하시오.

컴퓨터 페러다임 중 하나로, 프로그래밍에서 **필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고** 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

## SOLID 원칙에 대해 설명해주세요.

우선 SOLID 원칙에는 SRP, OCP, LSP, DIP, ISP 가 존재합니다.
이 원칙을 적용해 유지 보수와 확장이 쉬운 소프트웨어를 만드는데 이 원칙들을 적용할 수 있습니다.

## Java의 구동원리를 설명하세요.

우선 프로세스는 크게 컴파일 타임, 런타임 환경으로 나뉩니다.  

자바 소스코드를 자바 컴파일러를 통해 바이트코드로 변환합니다. 여기까지가 컴파일 타임 환경이고요 
런타임 환경에서는 가장 첫번째로 변환된 바이트코드를 ClassLoader를 통해 JVM 메모리, Runtime Data Area 로 뿌려지게 됩니다.  

JVM 구조에 대해 간략히 설명하자면 ClassLoader, RuntimeDataArea, Execution Engine 이 있습니다.

## GC에 대해서 더 자세하게 알려주세요

GC는 RuntimeDataArea 중 Heap 영역에서만 수행하게 되고요.  
자바의 메모리 영역은 크게 Young 영역과 Old 영역으로 나뉘게 됩니다.  
Young 영역에서는 Minor GC가 발생하고 Old 영역에서는 Major GC가 발생합니다.  
GC 의 정도는 Young 영역이 Old 영역보다 심합니다.

## 쓰레드란 무엇이고, 싱글쓰레드와 멀티쓰레드 차이를 설명해주세요.

쓰레드는 프로세스를 처리하기 위한 일련의 단위인데요.  
프로세스 1을 처리하기 위해 단일 쓰레드가 동작하면 싱글쓰레드, 2개 이상의 쓰레드가 동작한다면 멀티쓰레드라고 볼 수 있습니다.

쓰레드의 특징을 한가지만 얘기하자면 순서를 보장하지 않는다는 특징이 있습니다.

## 클래스는 무엇이고, 객체는 무엇인지 설명해주세요.

클래스는 객체를 만들기 위한 설계도, 혹은 그 틀을 말하고, 객체는 소프트웨어 세계에 구현할 대상을 말합니다.

## 인터페이스와 추상클래스의 차이점은 무엇인지 설명해주세요.

추상클래스는 상속을 통해 자손클래스에서 완성하도록 유도하는 클래스이며, 미완성 설계도(IS~A) 라고 표현할 수 있습니다.

인터페이스는 기본 설계도(HAS~A)로 표현할 수 있으며, 다중상속이 가능하다는 차별점이 존재합니다.

## 직렬화가 무엇인지 설명하세요.

자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 -> 직렬화  
바이트로 변환된 데이터를 다시 객체로 변환할 수 있는 기술을 아울려 이야기 해요. -> 역직렬화  

DB의 직렬화 역직렬화와 로직이 유사하다고 할 수 있어요.

## Call by Value와 Call by Reference의 차이에 대해 설명해주세요.

인자로 받은 값을 복사해서 처리하냐, 인자로 받은 값은 값의 주소를 참조하여 값의 영향을 주냐의 얘기예요.  
개인적인 생각이지만, shallow copy와 deep copy의 개념과 비슷하다고 생각해요.

## Checked Exception과 Unchecked Exception의 차이를 설명해주세요.

Exception 핸들링이 필요하냐 필요없냐의 차이예요.  
checked exception은 무조건 Exception 핸들링이 필요하고, unchecked exception은 하지 않아도 돼요.
시범은 checked 가 compile 시점, unchecked 가 runtime 시점이예요.

## JVM의 역할을 설명하세요

JVM 은 Java Virtual Machine 으로 자바 가상 머신을 줄여 부른거예요.
JVM 은 classLoader를 통해 class 파일들을 JVM 으로 로딩해요.  
JVM 은 메모리를 효율적으로 관리해주며, 클래스 파일을 해석하여 실질적인 수행까지 맡아요.

## JDBC란 무엇인가요?

Java Database Connectivity 로 자바에서 DB 프로그래밍을 하기 위해 사용돼요.
Hibernate orm framework 또한 내부적으로 JDBC API를 사용해요.

## Hibernate란 무엇인가요?

하이버네이트는 자바 언어를 위한 ORM 프레임워크예요.  
JPA의 구현체로, JPA 인터페이스를 구현하며, 내부적으로 JDBC API를 사용해요.

## JPA 의 장점은요?

JPA는 관계형 데이터베이스와 객체의 페러다임 불일치 문제를 해결할 수 있다는 점과 영속성 컨텍스트를 제공이 큰 특징이예요.

객체를 불러올 때, 연관된 객체 또한 함께 불러오기 때문에, SQL에 의존적이지 않은 개발을 할 수 있어요.  
즉, SQL 중심이 아닌 객체 중심의 개발이 가능해요.

## Data JPA 보다 Querydsl로 쿼리를 처리하는걸 선호하는 이유에 대해 알려주세요.

문자가 아닌 코드로 쿼리를 작성함으로써, 컴파일 시점에 문법 오류를 쉽게 확인할 수 있어요.   
자동 완성 등 IDE의 도움을 받을 수 있어요.  
동적인 쿼리 작성이 편리해요.

## 동시성 이슈에 대해서 방어할 수 있는 방법을 알려주세요.

* SRP 해야해요.
* 자료의 범위를 제한해요.
  *  코드 내 임계영역을 `synchornized` 키워드로 보호하는 것을 권장해요.
     * 플러스, 싱글톤에서 동시성 이슈를 제거하기 위해 모든 요청에 대해 `synchornized` 로직을 거치는건 성능적인 이슈가 있어요.
  *  자료를 캡슐화해요 공유 자료를 최대한 줄이는 것이 좋아요.
* 자료의 사본을 사용해요.
  * 객체를 복사해 읽기 전용으로 사용해요.
  * 한 쓰레드 마다 객체를 복사해 사용할 수도 있어요.
* 쓰레드를 가능한 독립적으로 구현해요.

## JPA를 사용하면서 N+1 문제에 대해서 알려주세요.
우선 N+1 문제란 조회할 데이터 N 만큼 연관관계 조회 쿼리가 발생하여 데이터를 읽어오게 되는 것이예요.  
JpaRepository에 정의한 메서드를 실행하면 명명규칙에 맞게 JPQL을 생성하여 실행하는데요 이때 JPQL 입장에서 연관관계 데이터를 무시하고 원하는 엔티티만 실행하게 되는 것이기 떄문에 발생하는 것이예요.  
이 문제는 `FetchJoin`, `@EntityGraph`를 통해 해결할 수 있어요.

## 벌크연산이 무엇이고 어떤 문제를 야기 시킬 수 있나요?

영속성컨텍스트와 1차 캐시를 무시하고 무시하고 네이티브 쿼리를 실행시켜 DB에 직접적으로 값을 바꾸고, 영속성컨텍스트에는 값이 반영되지 않게 하는 것. 예를 들어 update 쿼리 메소드를 실행시켰는데 1차캐시에는 반영되지 않고, DB에만 반영된 것.

## EAGER로딩과 LAZY로딩에 대해 설명해주세요
우선 즉시로딩은 객체A를 가져올 때 연관된 객체 B를 즉시 가져오는 방법이고요.  
한 네트워크로 2개의 객체 정보를 가져옵니다. (매번 A와 B를 같이 조회해야 할 때 이점을 보입니다.)

지연로딩은 객체A를 가져올 때 연관된 객체 B에 대해서 proxy 엔티티를 우선적으로 반환하고 실제로 객체A에 연관된 B를 접근할 때 조회 쿼리를 날리는 것입니다.

## 싱글톤 패턴은 무엇인가요?
우선 싱글톤 패턴 적용 예로는 intelliJ의 인터페이스 즉 모든 사용자가 같은 인터페이스, 같은 설정의 정보를 가져야 할 때 객체가 여러개 생성되면 값이 변경될 위험이 있기 때문에 싱글톤으로 구현합니다.  

thread-safe 하게 싱글톤을 구현하는 방법으로는 `Synchronized` 키워드를 통해 실현 할 수 있고, Double Check 기법, LazyHoder를 사용하는 방법등이 있습니다.

하지만 이 방법들은 thread-safe 하지만, 리플랙션으로 언제든지 조작이 가능합니다. 리플랙션으로 조작할 수 없는 싱글톤을 구현하려면 리플랙션이 막혀있는 enum class의 특징을 활용해 구현 가능합니다.