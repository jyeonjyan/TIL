# 내가 이력서에 알고 있다고 한것들 정리하기
> 이력서는 제발 진짜 제대로 알고 있는것만 작성하자.  
> 운 좋게 서류는 통과할지 몰라도 기술면접에서 뽀록난다 ^^ 

## 객체지향에 대해서 설명하시오.

컴퓨터 페러다임 중 하나로, 프로그래밍에서 **필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고** 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

## SOLID 원칙에 대해 설명해주세요.

우선 SOLID 원칙에는 SRP, OCP, LSP, ISP, DIP 가 존재합니다.  
이 원칙을 적용해 유지 보수와 확장이 쉬운 소프트웨어를 만드는데 이 원칙들을 적용할 수 있습니다.  

### 스프링에서 가장 중요한걸 굳이 뽑자면?

OCP 와 DIP 입니다.  
* OCP는 확장에는 열려있지만 수정에는 닫혀 있다는 개념을 베이스로 한 원칙입니다.  
* DIP는 추상화에 의존해야지 구체화에 의존하면 안된다는 개념을 베이스로 한 원칙입니다. (A가 tesla사의 자동차를 산다.(O) A가 tesla model3를 산다.(x))
  * DIP를 지켜야지 유연한 변경이 가능함.

## Java의 구동원리를 설명하세요.

우선 프로세스는 크게 컴파일 타임, 런타임 환경으로 나뉩니다.  

자바 소스코드를 자바 컴파일러를 통해 바이트코드로 변환합니다. 여기까지가 컴파일 타임 환경이고요.  

런타임 환경에서는 가장 첫번째로 변환된 바이트코드를 ClassLoader를 통해 JVM 메모리, Runtime Data Area 로 뿌려지게 됩니다.  

JVM 구조에 대해 간략히 설명하자면 ClassLoader, RuntimeDataArea, Execution Engine 이 있습니다.

### GC 의 대상이 되는 영역은 어디인가요

GC의 대상은 RuntimeDataArea 5가지 영역 `PC register`, `jvm stack`, `native method stack`, `heap`, `method area` 중 `heap` 영역만 대상 영역이 됩니다.

GC 는 사용하지 않는 객체의 메모리를 청소해주는 역할을 합니다.

* `PC register`, `jvm stack`, `native method stack` 은 각각 쓰레드 별로 생성되고
* `heap`, `method area` 은 모든 쓰레드가 공유합니다.

### Execution Engine에 대해 자세히 알려주세요

execution engine은 실행엔진으로 두 가지 방식으로 동작합니다.  
자바 인터프리터와 JIT 컴파일러 입니다.

* 자바 인터프리터는 바이트코드 명령어를 하나씩 읽어 해석하고 실행한다. 하나하나의 실행은 빠르나 전체적으로 봤을 때는 느림
  
### JIT 컴파일러에 대해서 알려주세요.

JIT 컴파일러는 크게 두 가지 역할을 합니다.  

인터프리터 방식의 단점(하나씩 인터프리팅하는 방식)을 보완해 미리 전체의 바이트코드를 바이너리코드로 미리 변환해두고, 상황에 맞게 바이너리 코드를 읽어 수행합니다.  
네이티브코드를 번역합니다. 네이티브코드는 java 로 작성되지 않고 C, C++로 작성된 코드를 의미하는데요 javac가 컴파일 할 수 없는 네이티브코드를 해석합니다.

### 네이티브 코드에 대해서 자세히 설명해주세요.

네이티브코드는 앞서 말햇듯이 java로 작성되지 않고 c, c++ 등의 다른 언어로 작성된 소스코드를 의미합니다.  
네이티브코드는 GC의 대상에서 제외되므로, 메모리 성능을 생각하여 적절하게 사용하는 것이 좋습니다.

## GC에 대해서 더 자세하게 알려주세요

GC는 RuntimeDataArea 중 Heap 영역에서만 수행하게 되고요.  
자바의 메모리 영역은 크게 Young 영역과 Old 영역으로 나뉘게 됩니다.  
Young 영역에서는 Minor GC가 발생하고 Old 영역에서는 Major GC가 발생합니다.  
GC 의 정도는 Young 영역이 Old 영역보다 심합니다.

* java 8 이후로 permgen 영역이 metaspace로 대체되었습니다.  
  * metaspace는 ClassLoader가 현제까지 로드한 class들의 metadata가 저장되는 공간입니다.

### 과정에 대해 더 자세하게요 

Young 영역은 또 3가지 eden, servivor, servivor1 영역으로 나뉘는데요.  
살아있는 객체는 young 영역에 eden 영역에 올라갑니다.  
eden 영역이 꽉 차면 servivor 영역에 살아있는 객체를 이동시킵니다.  
servivor 영역이 꽉 차면 servivor1 영역에 있는 객체를 old 영역으로 옮기고 이동시킵니다.

## 쓰레드란 무엇이고, 싱글쓰레드와 멀티쓰레드 차이를 설명해주세요.

쓰레드는 프로세스를 처리하기 위한 일련의 단위인데요.  
프로세스 1을 처리하기 위해 단일 쓰레드가 동작하면 싱글쓰레드, 2개 이상의 쓰레드가 동작한다면 멀티쓰레드라고 볼 수 있습니다.

쓰레드의 특징을 한가지만 얘기하자면 순서를 보장하지 않는다는 특징이 있습니다.

## 클래스는 무엇이고, 객체는 무엇인지 설명해주세요.

클래스는 객체를 만들기 위한 설계도, 혹은 그 틀을 말하고, 객체는 소프트웨어 세계에 구현할 대상을 말합니다.

## 정적(static)이란 무엇일까요?

클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모르 영역에 적재할 때 클래스별로 관리됩니다.  
GC 관리 영역 밖에 존재하기 때문에 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.

## 자바 원시타입은 각각 몇 바이트를 차지하나요?

* 1byte: boolean, byte
* 2byte: char, short
* 4byte: int, float
* 8byte: long, double


## 인터페이스와 추상클래스의 차이점은 무엇인지 설명해주세요.

추상클래스는 상속을 통해 자손클래스에서 완성하도록 유도하는 클래스이며, 미완성 설계도(IS~A) 라고 표현할 수 있습니다.

인터페이스는 기본 설계도(HAS~A)로 표현할 수 있으며, 다중상속이 가능하다는 차별점이 존재합니다.

## 직렬화가 무엇인지 설명하세요.

자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 -> 직렬화  
바이트로 변환된 데이터를 다시 객체로 변환할 수 있는 기술을 아울려 이야기 해요. -> 역직렬화  

## Call by Value와 Call by Reference의 차이에 대해 설명해주세요.

CBV(Call By Value)는 기본적으로 대상에 주소값을 가지지 않는 것으로 값을 할당받는 형태로 사용됩니다. primitive type 에 해당됩니다.  

CBR(Call By Reference)는 대상을 선언했을 때 주소값이 부여됩니다. 그래서 어떠한 객체를 불러왔을 때는 주소값을 불러온다고 봅니다. Class, Object 가 CBR에 해당합니다.

### 자바에서의 call by reference는 어떻게 동작하나요?

JAVA에서 Call by reference는 해당 객체의 주소값을 직접 넘기는 게 아닌 객체를 보는 또 다른 주소값을 만들어서 넘기다는 사실을 꼭 기억하자. 

### .equals() 와 == 의 차이에 대해 알려주세요.

`.equals()`는 비교하고자 하는 대상의 **내용 자체**를 비교하지만.
`==` 연산자는 비교하고자 하는 **대상의 주소값**을 비교합니다.

```java
String str1 = "Hello, world!";
String str2 = str1;
String str3 = new String("Hello, world!");

System.out.println(str1 == str2); // true
System.out.println(str2 == str3); // false
System.out.println(str1.equals(str3)); // true
```

## Checked Exception과 Unchecked Exception의 차이를 설명해주세요.

Exception 핸들링이 필요하냐 필요없냐의 차이예요.  
checked exception은 무조건 Exception 핸들링이 필요하고, unchecked exception은 하지 않아도 돼요.
시범은 checked 가 compile 시점, unchecked 가 runtime 시점이예요.

## JVM의 역할을 설명하세요

JVM 은 Java Virtual Machine 으로 자바 가상 머신을 줄여 부른거예요.
JVM 은 classLoader를 통해 class 파일들을 JVM 으로 로딩해요.  
JVM 은 메모리를 효율적으로 관리해주며, 클래스 파일을 해석하여 실질적인 수행까지 맡아요.

## JDBC란 무엇인가요?

Java Database Connectivity 로 자바에서 DB 프로그래밍을 하기 위해 사용돼요.
Hibernate orm framework 또한 내부적으로 JDBC API를 사용해요.

## Hibernate란 무엇인가요?

하이버네이트는 자바 언어를 위한 ORM 프레임워크예요.  
JPA의 구현체로, JPA 인터페이스를 구현하며, 내부적으로 JDBC API를 사용해요.

## 싱글톤 패턴은 무엇인가요?
프로그램 내에서 단 1개만 존재해야 하는 객체가 있으며, 이를 프로그램 내부의 여러 부분에서 호출하여 사용하는 경우에 사용 가능합니다.  
멀티 쓰레드에서 이 객체를 공유하며 동시에 접근하는 동시성 이슈도 해결해주는 디자인 패턴입니다.  

(적용 예로는 intelliJ의 인터페이스 즉 모든 사용자가 같은 인터페이스, 같은 설정의 정보를 가져야 할 때 객체 하나로 여러 사용자에게 공유해야 합니다.)

thread-safe 하게 싱글톤을 구현하는 방법으로는 `Synchronized` 키워드를 통해 실현 할 수 있고, `Double Check` 기법, 마지막으로 가장 많이 사용되는 `LazyHoder`를 사용하는 방법 등이 있습니다.  
하지만 이 방법들은 thread-safe 하지만, 리플랙션으로 언제든지 조작이 가능합니다.  

**리플랙션으로 조작할 수 없는 싱글톤을 구현하려면 리플랙션이 막혀있는 enum class의 특징을 활용해 구현 가능합니다.**

## 자바 제네릭에 대해서 알려주세요.

클래스에서 사용할 타입을 외부에서 설정하는 것입니다.  
비슷한 기능을 지원하는 경우 코드의 재사용성이 높아집니다.

선택사항
* Raw 타입, Object 타입을 사용하면 컴파일 시점에서 오류를 잡아낼 수 없다. (타입 매개변수를 지정하는 것이 좋다)
* 배열보다는 리스트를 사용하라 (제네릭은 런타임 시점에 ClassCastException을 만나지 않고, 컴파일 시점에 오류를 잡아낼 수 있다.)
* 한정적 와일드카드를 사용해 API의 유연성을 높여라. (반환 값에 한정적 와일드카드를 적용하는 것은 오히려 유연성을 떨어뜨린다.)

### 자바 제네릭의 기능

* `extends T` : 상한 경계
* `? super T` : 하한 경계
* `<?>` 와일드카드

**잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있습니다.**

## 동시성 이슈에 대해서 방어할 수 있는 방법을 알려주세요.

* SRP 해야해요.
* 자료의 범위를 제한해요.
  *  코드 내 임계영역을 `synchornized` 키워드로 보호하는 것을 권장해요.
     * 플러스, 싱글톤에서 동시성 이슈를 제거하기 위해 모든 요청에 대해 `synchornized` 로직을 거치는건 성능적인 이슈가 있어요.
  *  자료를 캡슐화해요 공유 자료를 최대한 줄이는 것이 좋아요.
* 자료의 사본을 사용해요.
  * 객체를 복사해 읽기 전용으로 사용해요.
  * 한 쓰레드 마다 객체를 복사해 사용할 수도 있어요.
* 쓰레드를 가능한 독립적으로 구현해요.

## 자바 8 이후 향상된 기능은 무엇인가요?
LTS 버전 기준 8, 11, 17 이렇게 설명드리겠습니다.  

### ~ java 8 LTS
* 람다 표현식
* StreamAPI
* interface default method
* java time 패키지
* CompletableFuture (비동기 처리 할 때 사용)
* Optional
* jvm PermGen이 사라지고 metaspace 영역으로 대체

### ~ java 11 LTS
> [java 11 이상으로 전환해야 하는 이유](https://docs.microsoft.com/ko-kr/java/openjdk/reasons-to-move-to-java-11?toc=/azure/developer/java/fundamentals/toc.json&bc=/azure/developer/breadcrumb/toc.json)

* 람다 파라미터를 위한 지역변수 표현
* HTTP 2 지원
* 모듈
* 프로파일링
* 가비지 수집
* docker 컨테이너의 향상된 기능
* 성능 향상


### ~ java 17 LTS
* LTS 주기의 변경
* 새로운 라이선스 적용

## hikariCP 가 무엇인가요

java 2.x 버전부터 springboot application의 기본 쓰레드 풀입니다.  
미리 정해진 만큼의 connection을 connection pool에 담아두고, 요청이 들어오면 thread가 hikari에 connection을 요청합니다.  
maximumPoolSize는 기본으로 10 입니다.  

## 자바 리플랙션 그리고 그걸로 얻을 수 있는 spring에 대한 이해가 어떤 것이였나요?

저희 학교 친구들만 해도 java reflection 모르고 DI 를 사용하는 경우가 많습니다.  
간단하게 설명하자면 리플랙션은 코드를 조작하는 기술입니다. 기본적으로 java 를 통해 바이트버디 등과 같은 라이브러리를 통해 바이트코드를 조작할 수 있습니다.

DI 는 자바의 리플랙션과 어노테이션 프로세서를 이용한 기술입니다.  
필드 주입을 예로 들면 `@Autowired` 가 달린 필드를 찾고 그 필드의 타입 인스턴스를 생성해 주입하는 방식입니다.

### DI 얘기가 나와서 그런데 DI 에 종류와 이들의 차이는 뭔가요?

* setter 주입
  * setter 주입은 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록 가능합니다.
* 생성자 주입
  * Lombok 에서 지원해주는 @RequiredArgsConstructor 를 사용하고 제일 선호하는 Injection 방식입니다.
  * 생성자 호출 시점에 딱 1번만 호출되는 것을 보장하며, 불변, 필수 의존관계에 사용합니다.
* 필드 주입
  * 순환참조를 일으킬 가능성이 크기 때문에 테스트코드 이외에서는 사용하지 않습니다.
  * DI 기능 확장에 제한적입니다.

## IoC 컨테이너는 뭔가요?

IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다.  
POJO의 생성, 초기화, 소멸에 대한 권한을 가진다.  
개발자들이 직접 POJO를 생성할 수 있지만 컨테이너에 맡긴다.

**개발자들은 복잡한 관계설정에 얽매이지 않고 비즈니스로직 구현에 집중할 수 있습니다.**

## 객체를 Bean 으로 등록하는 이유는 무엇인가요

객체에 대해 생성과 소멸을 IoC 컨테이너에 위임하기 위함입니다.  
Bean 으로 등록된 객체는 편하게 IoC 컨테이너로부터 미리 생성된 객체를 가져와서 사용할 수 있습니다.

### BeanFactory 는 무엇인가요?

스프링 컨테이너의 최상위 인터페이스입니다.  
컨테이너에서 객체를 생성하고 DI를 처리해주는 기능만을 제공한다.  
* Bean을 등록, 생성, 조회(`.getBean()`), 반환 관리 함.

### ApplicationContext = spring container 는 무엇인가요?

빈팩토리와 유사한 기능을 제공하지만 좀 더 많은 기능을 제공하는 컨텍스트다.  
Bean을 관리한다는 점은 BeanFactory와 같다. (상속 받아 모두 사용 가능)  

- 차이점 
  - 국제화가 지원되는 텍스트 메시지를 관리
  - 이미지같은 파일 자원을 로드할 수 있는 포괄적인 방법 제공
  - 리스너로 등록된 빈에게 이벤트 발생을 알려줌.
  
**Bean을 지연없이 얻을 수 있다 미리 Bean을 생성해 놓아 빈을 필요할 때 즉시 사용할 수 있도록 보장한다.**

## POJO 는 무엇이고 사용 예는 어떻게 될 수 있을까요?
POJO 는 Plain Old Java Object의 약자로 Java API 를 제외한 다른 API에 의존적이지 않으며  
spring 기준으로 `도메인` 과 `비즈니스 로직`이 POJO 의 대상이 될 수 있습니다.

## Servlet filter 와 Intercpetor의 차이가 무엇인가요?

* filter
  * DispatcherServlet 보다 먼저 위치해 있으며 Servlet 스팩에 포함됩니다.

* Intercptor
  * spring application 내부에 위치에 있습니다.
  * spring에서 Handler를 실행하기 전후에 실행합니다.
  * spring 의 application context 에 등록합니다.
  * HttpServletRequest 혹은 HttpServeltResponse 사용이 가능해 사용자 인증, 자원 접근, 로깅에 사용됩니다.

## Spring에서 CORS를 해결하는 방법을 설명해주세요

저는 webConfig 라는 클래스를 만들고 해당 클래스에 `@Configuration` 애노테이션을 통해 allow origin 해줍니다.

* servlet filter 에서 커스텀한 cors 를 설정할 수도 있습니다.  

* controller 에 개별적으로 `@Crossorigin` 사용해서 설정할 수도 있습니다.

## Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?

* filter 는 DispatcherServlet 밖에 존재합니다. ErrorController 를 통해 처리해야 합니다.
* interceptor은 DispatcherServlet 안에 존재하여 `@ControllerAdvice` 를 통해 처리할 수 있습니다.

## JPA 의 장점은요?

JPA는 관계형 데이터베이스와 객체의 페러다임 불일치 문제를 해결할 수 있다는 점과 영속성 컨텍스트를 제공이 큰 특징이예요.

객체를 불러올 때, 연관된 객체 또한 함께 불러오기 때문에, SQL에 의존적이지 않은 개발을 할 수 있어요.  
즉, SQL 중심이 아닌 객체 중심의 개발이 가능해요.

## JPA 영속성 컨텍스트가 뭔가요?
영속성 컨텍스트는 데이터를 영구히 저장할 수 있게 해주는 공간이라 생각하면 쉬운데요.  
1차 캐시 저장소와, 쿼리문 저장소로 나뉩니다.

### 영속성 컨텍스트의 이점이 5가지는 뭔가요?

* 1차캐시
* 더티체킹
* 동일성 보장
* 쓰기 지연
* 지연로딩

## 엔티티의 생명주기는 어떻게 되나요?
* 비영속 상태
  * 엔티티가 영속성 컨텍스트와 전혀 관련이 없는 상태입니다.
* 영속 상태
  * `.persist()` 메소드를 통해 실현할 수 있고
  * 엔티티가 영속성 컨텍스트에서 관리되는 상태입니다. 
* 준영속 상태
  * 관리 되던 엔티티가 관리되지 않게 되는 상태를 준영속 상태라고 합니다.
  * `.detach()`, `.clear()`, `.close()`, `remove()` 를 사용할 수 있습니다.

## Data JPA 보다 Querydsl로 쿼리를 처리하는걸 선호하는 이유에 대해 알려주세요.

문자가 아닌 코드로 쿼리를 작성함으로써, 컴파일 시점에 문법 오류를 쉽게 확인할 수 있어요.   
자동 완성 등 IDE의 도움을 받을 수 있어요.  
동적인 쿼리 작성이 편리해요.

## JPA를 사용하면서 N+1 문제에 대해서 알려주세요.
우선 N+1 문제란 조회할 데이터 N 만큼 연관관계 조회 쿼리가 발생하여 데이터를 읽어오게 되는 것이예요.  
JpaRepository에 정의한 메서드를 실행하면 명명규칙에 맞게 JPQL을 생성하여 실행하는데요 이때 JPQL 입장에서 연관관계 데이터를 무시하고 원하는 엔티티만 실행하게 되는 것이기 떄문에 발생하는 것이예요.  
이 문제는 `FetchJoin`, `@EntityGraph`를 통해 해결할 수 있어요.  
되도록이면 `@OneToMany` 매핑을 하지 않는게 최고의 예방책이예요.

## 벌크연산이 무엇이고 어떤 문제를 야기 시킬 수 있나요?

영속성컨텍스트와 1차 캐시를 무시하고 무시하고 네이티브 쿼리를 실행시켜 DB에 직접적으로 값을 바꾸고, 영속성컨텍스트에는 값이 반영되지 않게 하는 것. 예를 들어 update 쿼리 메소드를 실행시켰는데 1차캐시에는 반영되지 않고, DB에만 반영된 것.

## EAGER로딩과 LAZY로딩에 대해 설명해주세요.

우선 즉시로딩은 객체A를 가져올 때 연관된 객체 B를 즉시 가져오는 방법이고요.  
한 네트워크로 2개의 객체 정보를 가져옵니다. (매번 A와 B를 같이 조회해야 할 때 이점을 보입니다.)

지연로딩은 객체A를 가져올 때 연관된 객체 B에 대해서 proxy 엔티티를 우선적으로 반환하고 실제로 객체A에 연관된 B를 접근할 때 조회 쿼리를 날리는 것입니다.

## TCP 와 UDP 차이를 알려주세요

TCP와 UDP의 가장 큰 차이는 신뢰성/비신뢰성 입니다.  
하지만 UDP 는 그 자체로서 비신뢰성일뿐 개발자의 추가적인 정의를 통해 갖도록 해줄 수 있습니다.  

**HTTP/3 스펙에서는 UDP를 기반으로 기술적 문제를 해결합니다.**

## OSI7계층의 존재 이유, TCP/IP 4계층에 대해 설명해보세요.

OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다.  
이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문데를 해결하기 용이해집니다.

실제로 우리가 사용하는 네트워크는 TCP/IP 4계층입니다. 

## 교착상태와 기아상태의 해결방법에 대해 설명해주세요.

교착상태가 무엇인지 알고 있어야 합니다.  
서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 생태를 의미합니다.  

**발생조건**
* 상호 배제: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.
* 점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.
* 비선점: 다른 프로세스가 자원의 사용을 끝날 때 까지 자원을 뺏을 수 없습니다.
* 순환대기: 각 프로세스가 순환적으로 프로세스가 요구하는 자원을 가지고 있습니다.

## OAuth 에 대해 알려주세요.

자자 서비스의 회원 로직을 사용하지 않고 다른 회사, 제 3자 인증방식 입니다.  
개인정보를 넘기는 것을 꺼려하기 때문에 신뢰할 수 있는 서버에게 정보를 맡겨놓고 접근할 수 있는 권한을 주는 것입니다.

## SDP 안정된 의존관계 원칙에 대해 설명해주세요.

자신이 안정적인 만큼 추상적이기도 해야 한다. 라는 의미에서 나온 개념인데요  
간단히 말하면 controller -> service -> repository 구조에서 

* controller는 불안정하므로 추상적인 필여가 없다 -> controller 클래스 interface를 만들고 구현하는 것은 무의미하다.
* repository는 매우 안정적이므로 추상적이여야 한다 -> repository는 interface를 만들고 구현하는 것이 좋다.
* service 는??

네 Service는 애매한 부분이 있습니다 그래서 상황에 따라 조사를 해봐야 한다는 의미입니다.
